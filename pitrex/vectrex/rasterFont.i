#ifdef AVOID_TICKS
#include <string.h>
#endif

// ASCI bitmap data
// starting with SPACE = 0x20
// up to XXX = 0x6f

// if the extended character set works, then find suitable font,
// and modify code so that the rasterline array can be passed in as
// a parameter...

// these are really 7x7 fonts.  The lowest (rightmost) bit is problematic.

unsigned char rasterline1[] = {
  0x00, 0x20, 0x50, 0x50, 0x20, 0xC8, 0x20, 0x10, 0x10, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08,
  0x30, 0x20, 0x70, 0x70, 0x10, 0xF8, 0x30, 0xF8, 0x70, 0x70, 0x00, 0x60, 0x00, 0x00, 0x00, 0x70,
  0x70, 0x20, 0xF0, 0x70, 0xF0, 0xF8, 0xF8, 0x78, 0x88, 0x70, 0x08, 0x88, 0x80, 0x88, 0x88, 0xF8,
  0xF0, 0x70, 0xF0, 0x70, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x88, 0xF8, 0x70, 0x80, 0x70, 0x20, 0x00,
  0x00, 0x20, 0x08, 0x20, 0x00, 0x00, 0x00, 0x38, 0x10, 0x20, 0x44, 0x44, 0x00, 0xFE, 0xFF, 0xFE,
  0x30, 0x20, 0x70, 0x70, 0x10, 0xF8, 0x30, 0xF8, 0x70, 0x70, 0x00, 0x60, 0x00, 0x00, 0x00, 0x70,
  0x70, 0x20, 0xF0, 0x70, 0xF0, 0xF8, 0xF8, 0x78, 0x88, 0x70, 0x08, 0x88, 0x80, 0x88, 0x88, 0xF8,
};

unsigned char rasterline2[] = {
  0x00, 0x70, 0x50, 0x50, 0x78, 0xC8, 0x50, 0x20, 0x20, 0x20, 0xA8, 0x20, 0x00, 0x00, 0x00, 0x08,
  0x48, 0x60, 0x88, 0x88, 0x30, 0x80, 0x40, 0x08, 0x88, 0x88, 0x60, 0x60, 0x10, 0x00, 0x40, 0x88,
  0x88, 0x50, 0x48, 0x88, 0x48, 0x80, 0x80, 0x80, 0x88, 0x20, 0x08, 0x90, 0x80, 0xD8, 0xC8, 0x88,
  0x88, 0x88, 0x88, 0x88, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x08, 0x40, 0x80, 0x08, 0x50, 0x00,
  0x00, 0x70, 0x0C, 0x20, 0x70, 0x70, 0x00, 0x44, 0x10, 0x70, 0x00, 0x00, 0x6C, 0x82, 0xFF, 0xFE,
  0x48, 0x60, 0x88, 0x88, 0x30, 0x80, 0x40, 0x08, 0x88, 0x88, 0x60, 0x60, 0x10, 0x00, 0x40, 0x88,
  0x88, 0x50, 0x48, 0x88, 0x48, 0x80, 0x80, 0x80, 0x88, 0x20, 0x08, 0x90, 0x80, 0xD8, 0xC8, 0x88,
};

unsigned char rasterline3[] = {
  0x00, 0x70, 0x50, 0xF8, 0xA0, 0x10, 0x50, 0x40, 0x40, 0x10, 0x70, 0x20, 0x00, 0x00, 0x00, 0x10,
  0x48, 0x20, 0x08, 0x08, 0x50, 0xF0, 0x80, 0x10, 0x88, 0x88, 0x60, 0x00, 0x20, 0x78, 0x20, 0x08,
  0xA8, 0x88, 0x48, 0x80, 0x48, 0x80, 0x80, 0x80, 0x88, 0x20, 0x08, 0xA0, 0x80, 0xA8, 0xA8, 0x88,
  0x88, 0x88, 0x88, 0x40, 0x20, 0x88, 0x88, 0x88, 0x50, 0x50, 0x10, 0x40, 0x40, 0x08, 0x88, 0x00,
  0x70, 0xA8, 0x0A, 0x20, 0x88, 0xF8, 0x60, 0xBA, 0x38, 0x20, 0x00, 0x00, 0x92, 0x82, 0xFF, 0xFE,
  0x48, 0x20, 0x08, 0x08, 0x50, 0xF0, 0x80, 0x10, 0x88, 0x88, 0x60, 0x00, 0x20, 0x78, 0x20, 0x08,
  0xA8, 0x88, 0x48, 0x80, 0x48, 0x80, 0x80, 0x80, 0x88, 0x20, 0x08, 0xA0, 0x80, 0xA8, 0xA8, 0x88,
};

unsigned char rasterline4[] = {
  0x00, 0x20, 0x00, 0x50, 0x70, 0x20, 0x60, 0x00, 0x40, 0x10, 0xA8, 0xF8, 0x00, 0x70, 0x00, 0x20,
  0x48, 0x20, 0x70, 0x30, 0x90, 0x08, 0xF0, 0x20, 0x70, 0x78, 0x00, 0x60, 0x40, 0x00, 0x10, 0x10,
  0xB8, 0x88, 0x70, 0x80, 0x48, 0xE0, 0xE0, 0x98, 0xF8, 0x20, 0x08, 0xC0, 0x80, 0xA8, 0x98, 0x88,
  0xF0, 0x88, 0xF0, 0x20, 0x20, 0x88, 0x50, 0xA8, 0x20, 0x20, 0x20, 0x40, 0x20, 0x08, 0x00, 0x00,
  0xFE, 0x20, 0x08, 0x20, 0x88, 0xF8, 0xF0, 0xA2, 0x38, 0xF8, 0x82, 0x38, 0x92, 0x82, 0xFF, 0xFE,
  0x48, 0x20, 0x70, 0x30, 0x90, 0x08, 0xF0, 0x20, 0x70, 0x78, 0x00, 0x60, 0x40, 0x00, 0x10, 0x10,
  0xB8, 0x88, 0x70, 0x80, 0x48, 0xE0, 0xE0, 0x98, 0xF8, 0x20, 0x08, 0xC0, 0x80, 0xA8, 0x98, 0x88,
};

unsigned char rasterline5[] = {
  0x00, 0x00, 0x00, 0xF8, 0x70, 0x40, 0xA8, 0x00, 0x40, 0x10, 0xA8, 0x20, 0x40, 0x00, 0x00, 0x40,
  0x48, 0x20, 0x80, 0x08, 0xF8, 0x08, 0x88, 0x40, 0x88, 0x08, 0x60, 0x60, 0x20, 0x78, 0x20, 0x20,
  0xB0, 0xF8, 0x48, 0x80, 0x48, 0x80, 0x80, 0x88, 0x88, 0x20, 0x08, 0xA0, 0x80, 0x88, 0x88, 0x88,
  0x80, 0xA8, 0xA0, 0x10, 0x20, 0x88, 0x50, 0xA8, 0x50, 0x20, 0x40, 0x40, 0x10, 0x08, 0x00, 0x00,
  0xFE, 0x20, 0x78, 0xA8, 0x88, 0xF8, 0xF0, 0xBA, 0x7C, 0x20, 0x44, 0x44, 0x6C, 0x82, 0xFF, 0xFE,
  0x48, 0x20, 0x80, 0x08, 0xF8, 0x08, 0x88, 0x40, 0x88, 0x08, 0x60, 0x60, 0x20, 0x78, 0x20, 0x20,
  0xB0, 0xF8, 0x48, 0x80, 0x48, 0x80, 0x80, 0x88, 0x88, 0x20, 0x08, 0xA0, 0x80, 0x88, 0x88, 0x88,
};

unsigned char rasterline6[] = {
  0x00, 0x00, 0x00, 0x50, 0x28, 0x98, 0x90, 0x00, 0x20, 0x20, 0x00, 0x20, 0x40, 0x00, 0x00, 0x80,
  0x48, 0x20, 0x80, 0x88, 0x10, 0x88, 0x88, 0x80, 0x88, 0x10, 0x60, 0x20, 0x10, 0x00, 0x40, 0x00,
  0x80, 0x88, 0x48, 0x88, 0x48, 0x80, 0x80, 0x88, 0x88, 0x20, 0x88, 0x90, 0x88, 0x88, 0x88, 0x88,
  0x80, 0x90, 0x90, 0x88, 0x20, 0x88, 0x20, 0xA8, 0x88, 0x20, 0x80, 0x40, 0x08, 0x08, 0x00, 0x00,
  0x48, 0x20, 0xF0, 0x70, 0x70, 0x70, 0x60, 0x44, 0x6C, 0x50, 0x38, 0x82, 0x00, 0x82, 0xFF, 0xFE,
  0x48, 0x20, 0x80, 0x88, 0x10, 0x88, 0x88, 0x80, 0x88, 0x10, 0x60, 0x20, 0x10, 0x00, 0x40, 0x00,
  0x80, 0x88, 0x48, 0x88, 0x48, 0x80, 0x80, 0x88, 0x88, 0x20, 0x88, 0x90, 0x88, 0x88, 0x88, 0x88,
};

unsigned char rasterline7[] = {
  0x00, 0x20, 0x00, 0x50, 0xF8, 0x98, 0x68, 0x00, 0x10, 0x40, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80,
  0x30, 0x70, 0xF8, 0x70, 0x10, 0x70, 0x70, 0x80, 0x70, 0x60, 0x00, 0x40, 0x00, 0x00, 0x00, 0x20,
  0x78, 0x88, 0xF0, 0x70, 0xF0, 0xF8, 0x80, 0x78, 0x88, 0x70, 0x70, 0x88, 0xF8, 0x88, 0x88, 0xF8,
  0x80, 0x68, 0x88, 0x70, 0x20, 0x70, 0x20, 0x50, 0x88, 0x20, 0xF8, 0x70, 0x08, 0x70, 0x00, 0xF8,
  0x00, 0x20, 0x60, 0x20, 0x00, 0x00, 0x00, 0x38, 0x82, 0x88, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFE,
  0x30, 0x70, 0xF8, 0x70, 0x10, 0x70, 0x70, 0x80, 0x70, 0x60, 0x00, 0x40, 0x00, 0x00, 0x00, 0x20,
  0x78, 0x88, 0xF0, 0x70, 0xF0, 0xF8, 0x80, 0x78, 0x88, 0x70, 0x70, 0x88, 0xF8, 0x88, 0x88, 0xF8,
};

unsigned char *rom_rasterlines[7] = {
  rasterline1, rasterline2, rasterline3, rasterline4, rasterline5, rasterline6, rasterline7
};

unsigned char **rasterlines = rom_rasterlines;

void v_set_font(unsigned char **userfont) {
  if (userfont == NULL) {
    rasterlines = rom_rasterlines;
  } else {
    rasterlines = userfont;
  }
}

// positions using scale $7f
// position in 8bit vectrex format
// zeroes before positioning
// leaves zeroed (side effect or explicit? can we remove that redundant zeroing?)

// print strings given in "C"/vectrex format (depending on delimiter)
//
// only large letters supported with the default Vectrex font, however we have
// added a call to allow replacement fonts.

// coordinates given in vectrex 8 bit

// ySize is a negative coordinate in $7f scale, which
// represents the downward movement for each line
// We should have cleaned up this interface and not copied it verbatim from the Vectrex

int v_printStringRaster (int8_t x, int8_t y, char *_string, int8_t xSize, int8_t ySize, unsigned char delimiter) {
  int cycles = 1811 - 3 * 234;

  if (_string[0] == delimiter) return 0; // empty string

  int i = 0;
  while (_string[i] != delimiter) {
    i++;
  }
  if (_string[i-1] != ' ') {
    char padded[i+3]; // gcc extension
    i = 0;
    while (_string[i] != delimiter) {
      padded[i] = _string[i];
      i++;
    }
    
    // some strings, specifically those with a set bit in the right-hand side, cause visible glitches at the left,
    // unless the last character is followed by a space.  I think this is a separate issue from that of one or
    // two character minimum length strings.
    
    padded[i] = ' '; // do we need 2 spaces for a 1-char string? test and confirm...
    padded[i+1] = delimiter;
    return v_printStringRaster (x, y, padded, xSize, ySize, delimiter);
  }

  // I don't know WHY - we sometimes need this!
  SET (VIA_port_b, 0x80);       // disable ramp, mux = y integrator, enable mux

  int8_t yoffset = 0;
  int8_t movementScale = 0x7f;
  int halfOffset = 0;

  if ((ABS (x) < 64) && (ABS (y) < 64)) {
    movementScale = 0x7f >> 1;
    x = x << 1;
    y = y << 1;
  }
  if (ABS (ySize * 7) < 64) {
    halfOffset = 1;
  }

#define RASTER_WAIT 17
#ifdef AVOID_TICKS
  disableLinuxInterrupts (strlen (_string) * RASTER_WAIT + ST_GAP_END);
#endif

  for (int i = 0; i < 7; i++) {
    ZERO_AND_WAIT ();
    unsigned char *string = (unsigned char *) _string;
    unsigned char *currentRasterline = rasterlines[i];

    UNZERO ();

    // move to position
    v_setScale (movementScale);
    v_moveToImmediate8 (x, y);

    // move to line in String (only y-movement)
    if (yoffset != 0) {
      if (halfOffset) {
        SET_YSH_IMMEDIATE_8 (yoffset << 1);
        SET_XSH_IMMEDIATE_8 (0);
        v_setScale (10);
      } else {
        SET_YSH_IMMEDIATE_8 (yoffset);
        SET_XSH_IMMEDIATE_8 (0);
        v_setScale (19);
      }
      START_T1_TIMER ();
      WAIT_T1_END ();
    } else {
      SET (VIA_port_a, 0x00);
      DELAY_XSH ();
    }
    // disable ramp and set y movement to 0
    SET (VIA_port_b, 0x80);     // disable ramp, mux = y integrator, enable mux
    DELAY_YSH ();
    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    DELAY_PORT_B_BEFORE_PORT_A ();

    // set width of text 
    SET (VIA_port_a, xSize);
    DELAY_XSH ();

    // prepare for raster output
    SET (VIA_aux_cntl, 0x18);

    SET (VIA_port_b, 0x01);     // enable ramp, mux = y integrator, disable mux

    // the vectorbeam is moving... now fill the shiftregister ASAP with the bitmap, and wait for 18 cycles to pass

    // print this rasterline!
    do {
      if (i == 0) cycles += 234;
      DELAY_CYCLES (RASTER_WAIT);       // wait for enable ramp, and printing the last letter

      // draw one char bitmap
      unsigned char charBitmap = currentRasterline[*string - 0x20];

      string++;
      SET (VIA_shift_reg, charBitmap);
    } while (*string != delimiter);
    DELAY_CYCLES (6);           // disabling ramp takes a certain amount of time! - reduce that from the original shift wait

    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    DELAY_CYCLES (4);

    // enable non raster output
#ifdef BEAM_LIGHT_BY_SHIFT
    SET (VIA_aux_cntl, 0x98);   // Shift Reg. Enabled, T1 PB7 Enabled
#endif

#ifdef BEAM_LIGHT_BY_CNTL
    SET (VIA_aux_cntl, 0x80);   // Shift reg mode = 000 free disable, T1 PB7 enabled 
#endif

    DELAY_CYCLES (2);
    yoffset = yoffset + ySize;
  }

  SET (VIA_shift_reg, 0);
//ZERO_AND_WAIT();
  ZERO_AND_CONTINUE ();
#ifdef AVOID_TICKS
  enableLinuxInterrupts ();
#endif
  return cycles;
}

// this function prints a string at the current position
// it doesn't "know" its position
// the function uses the same technique as the vectrex
// print one line forth... than
// goes back the same amount of time and prints the next line
// due to that it is also prone to "drift"

// not working good, timer of pi not exact enough!

// DEPRECATED CALL.  DO NOT USE UNLESS YOU HAVE TO.  MAY BE REMOVED UNLESS IT IS FIXED...
void v_printStringRaster_here (char *_string, int8_t xSize, int8_t ySize, unsigned char delimiter) {
  // prepare for raster output
  SET (VIA_aux_cntl, 0x18);

#define RASTER_HERE_WAIT 15
#ifdef AVOID_TICKS
  disableLinuxInterrupts (strlen (_string) * RASTER_HERE_WAIT + ST_GAP_END);
#endif

  for (int i = 0; i < 7; i++) {
    unsigned char *string = (unsigned char *) _string;
    unsigned char *currentRasterline = rasterlines[i];

    // disable ramp and set y moevemtn to 0
    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    DELAY_YSH ();
    SET (VIA_port_a, 0x00);
    DELAY_PORT_B_BEFORE_PORT_A ();
    SET (VIA_port_b, 0x80);     // disable ramp, mux = y integrator, enable mux
    DELAY_YSH ();
    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    DELAY_PORT_B_BEFORE_PORT_A ();

    // set width of text 
    SET (VIA_port_a, xSize);
    DELAY_YSH ();

    setMarkStart ();            // set a clean timer mark befor ramping
    SET (VIA_port_b, 0x01);     // enable ramp, mux = y integrator, disable mux
    // the vectorbeam is moving... now fill the shiftregister ASAP with the bitmap, and wait for 18 cycles to pass

    // print this rasterline!
    do {
      DELAY_CYCLES (RASTER_HERE_WAIT);  // wait for enable ramp, and printing the last letter
      // draw one char bitmap
      unsigned char charBitmap = currentRasterline[*string - 0x20];

      string++;
      SET (VIA_shift_reg, charBitmap);
    } while (*string != delimiter);
    DELAY_CYCLES (6);           // disabling ramp takes a certain amount of time! - reduce that from the original shift wait

    // get a clean timer count, just before disabling the ramp
    int timeTaken = waitFullMicro ();

    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    DELAY_CYCLES (4);

// no difference DELAY_CYCLES(14);

/* */

// now go back for exactly the same time

    // set width of text 
    SET (VIA_port_a, -xSize);
    DELAY_YSH ();

    setMarkStart ();            // set a clean timer mark befor ramping
    SET (VIA_port_b, 0x01);     // enable ramp, mux = y integrator, disable mux
    waitMarkEnd (timeTaken);    // wait till exactly that timer expired

    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    DELAY_CYCLES (4);           // no difference DELAY_CYCLES(14);

                                // go down a tiny little bit:

    SET (VIA_port_a, ySize);    // set height of text
    DELAY_YSH ();

    SET (VIA_port_b, 0x80);     // disable ramp, mux = y integrator, enable mux
    DELAY_YSH ();
    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    DELAY_PORT_B_BEFORE_PORT_A ();
    SET (VIA_port_a, 0);        // x zero
    DELAY_YSH ();

    SET (VIA_port_b, 0x01);     // enable ramp, mux = y integrator, disable mux

    // the vectorbeam is moving... now fill the shiftregister ASAP with the bitmap, and wait for 18 cycles to pass
    DELAY_CYCLES (4);
    SET (VIA_port_b, 0x81);     // disable ramp, mux = y integrator, disable mux
    // no difference      DELAY_CYCLES(18);
  }
// enable non raster output
#ifdef BEAM_LIGHT_BY_SHIFT
  SET (VIA_aux_cntl, 0x98);     // Shift Reg. Enabled, T1 PB7 Enabled
#endif
  
#ifdef BEAM_LIGHT_BY_CNTL
  SET (VIA_aux_cntl, 0x80);     // Shift reg mode = 000 free disable, T1 PB7 enabled 
#endif

#ifdef AVOID_TICKS
  enableLinuxInterrupts ();
#endif
}
