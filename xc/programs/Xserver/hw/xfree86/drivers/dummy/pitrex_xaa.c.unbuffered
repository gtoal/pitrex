/* XAA vector drawing functions for PiTrex
 * Based on drivers/nv/riva_xaa.c
 *
 * Note: Still need a way to do single points (stars). Not accomodated
 *       by XAA.
 */

#include <unistd.h>
#include <stdio.h>
#include <pitrex/pitrexio-gpio.h>
#include <vectrex/vectrexInterface.h>
#include "dummy.h"
#include "pitrex_xaa.h"

#include "xaalocal.h"
#include "xaarop.h"

#include "miline.h"

char beamintensity;
unsigned int xdim;
unsigned int ydim;
//#define PITREX_DEBUG

/* Checks for whether a recal is required.
 * Always draws up to the maximum recal interval - a traditional WaitRecal
 * may allow for a cleaner display, but only possible with buffered vector
 * lists. Or is it? 
 */
void __svgalib_vectrex_recalcheck(void)
{
        if (GET (VIA_int_flags) & 0x20)
        {
         v_WaitRecal();
         v_readButtons();
        }
}

static void
PitrexSetupForSolidLine(ScrnInfoPtr pScrn, int color, int rop, unsigned planemask)
{
 /* TODO: Set intensity from colour - same problem as settings for per-game config. */
 /* v_WaitRecal here? */
#ifdef PITREX_DEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "X-vectrex: line set-up.\n");
#endif
}

int __pitrex_xaa_vectrex_scalexcoordinate(int coordinate)
{       /* Urgent-TODO: Where do I get the current resolution?
           -Part of pScrn structure in DUMMYPreInit? - And DUMMYScreenInit?*/
        return ( (int)((coordinate / (float)xdim) * 65535) - 32767 ) /2;
}

int __pitrex_xaa_vectrex_scaleycoordinate(int coordinate)
{
        return ( (~((int)((coordinate / (float)ydim) * 65535) - 32767)) + 1 ) /2;
}

static void 
PitrexSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn, int x1, int y1,
                              int x2, int y2, int flags)
{
        if (beamintensity <= 0) return;

        __svgalib_vectrex_recalcheck();
/*
#ifdef PITREX_DEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "X-vectrex: Draw Input = %d,%d-%d,%d.\n", x1, y1, x2, y2);
#endif
*/
#ifdef WINDOW
        v_brightness(beamintensity);
        v_line(x1, y1, x2, y2);
#else
        v_directDraw32  (
                                 __pitrex_xaa_vectrex_scalexcoordinate(x1),
                                 __pitrex_xaa_vectrex_scaleycoordinate(y1),
                                 __pitrex_xaa_vectrex_scalexcoordinate(x2),
                                 __pitrex_xaa_vectrex_scaleycoordinate(y2),
                                 beamintensity
                                );
#endif
}

/* Horizontal lines always drawn to the right (DEGREES_0)
 * Vertical lines always drawn down (DEGREES_270)
 */
static void 
PitrexSubsequentSolidHorVertLine(ScrnInfoPtr pScrn, int x, int y, int len, int dir)
{
 if (dir == DEGREES_0)
  PitrexSubsequentSolidTwoPointLine(pScrn, x, y, x+len, y, 0);
 if (dir == DEGREES_270)
  PitrexSubsequentSolidTwoPointLine(pScrn, x, y, x, y+len, 0);
#ifdef PITREX_DEBUG
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "X-vectrex: hor-vert_line.\n");
#endif
}

static void PitrexSubsequentSolidBresenhamLine(ScrnInfoPtr pScrn,
        int x, int y, int major, int minor, int err, int len, int octant)
{
#ifdef PITREX_DEBUG
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "X-vectrex: Bresenham Line.\n");
#endif
}

static void
PitrexSetupForSolidFill(ScrnInfoPtr pScrn, int color, int rop, unsigned planemask)
{
 /* TODO: Set intensity from colour - same problem as settings for per-game config. */
 /* v_WaitRecal here? */
//        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "X-vectrex: solid set-up.\n");
}

static void
PitrexSubsequentSolidFillRect(ScrnInfoPtr pScrn, int x, int y, int w, int h)
{

 if (h > 100)
 {
  v_WaitRecal();
  v_readButtons();
 }
/*
 PitrexSubsequentSolidTwoPointLine(pScrn, x, y, x+w, y, 0);
 PitrexSubsequentSolidTwoPointLine(pScrn, x+w, y, x+w, y+h, 0);
 PitrexSubsequentSolidTwoPointLine(pScrn, x+w, y+h, x, y+h, 0);
 PitrexSubsequentSolidTwoPointLine(pScrn, x, y+h, x, y, 0);
*/
#ifdef PITREX_DEBUG
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "X-vectrex: Rect.\n");
#endif
}

void PitrexSync(ScrnInfoPtr pScrn)
{
/* only needed if we implement a raster-readable vector buffer */
//         v_WaitRecal(); /* This almost works, but there are gaps between calls */
}

Bool pitrexXAAinit(ScreenPtr pScreen)
{
    XAAInfoRecPtr infoPtr;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
//    pitrexPtr pPitrex = pitrexPTR(pScrn);

//    pPitrex->AccelInfoRec = 
    infoPtr = XAACreateInfoRec();
    if(!infoPtr) return FALSE;

    /* sync */
    infoPtr->Sync = PitrexSync;

    /* Line drawing */
    infoPtr->SolidLineFlags = 0;
    infoPtr->SetupForSolidLine = PitrexSetupForSolidLine;
    infoPtr->SubsequentSolidTwoPointLine = 
		PitrexSubsequentSolidTwoPointLine;
    infoPtr->SubsequentSolidHorVertLine =
                PitrexSubsequentSolidHorVertLine;
    infoPtr->SubsequentSolidBresenhamLine =
                PitrexSubsequentSolidBresenhamLine;

    infoPtr->SetupForSolidFill = PitrexSetupForSolidFill;
    infoPtr->SubsequentSolidFillRect = PitrexSubsequentSolidFillRect;
/* TODO:

    infoPtr->SubsequentSolidFillTrap = PiTrexSubsequentSolidFillTrap;
    infoPtr->SetupForDashedLine = PitrexSetupForDashedLine;
    infoPtr->SubsequentDashedTwoPointLine = PitrexSubsequentDashedTwoPointLine;
*/
    /* Based on xf86SetDpi in common/xf86Helper.c, also RivaScreenInit in drivers/nv/riva_driver.c
     * -Is this / Can I be ignoring the window size? */
    xdim = pScrn->virtualX;
    ydim = pScrn->virtualY;
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Starting Vectrex Display\n");
    if (!vectrexinit(1) )
    {
     xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could Not Initialise Vectrex Connection\n");
     return FALSE;
    }
     v_setName("X_generic"); /* TODO: per-game settings... somehow */
     v_init();
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Started Vectrex Display\n");

     beamintensity = 100;
     v_setRefresh (50);
     v_directDraw32(20,20,60,60,90);
     
#ifdef WINDOW
        v_window(0, ydim, xdim, 0, NO_CLIP);
#endif

     return(XAAInit(pScreen, infoPtr));
}
