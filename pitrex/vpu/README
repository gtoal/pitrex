This program displays a vector pipeline generated by the Vectrex
Interface Library using the GPU (specifically with its unused VPU
core). For testing, it can also be compiled so that it can run on
the CPU. Running on the GPU avoids the timing issues associated with
running vector drawing code on the CPU, due to Linux tick interrupts
and multi-core cache wait states (Pi Zero 2).

Memory is allocated for the vector pipeline data in the GPU's memory
space and corresponding memory addresses are writen to the file
"/tmp/pitrex_gpu_mem". The Vectrex Interface library checks for this
file during initialisation and, if found, uses the GPU to display
the vector pipeline instead of processing the pipeline itself.

To build for the VPU, the vc4-toolchain is required, from here:
https://github.com/itszor/vc4-toolchain
Compile vc4-toolchain, then edit Makefile.vpu with the path to your
vc4-toolchain location. Note that compiling vc4-toolchain on a RPi
Zero will probably take an eternity - it's fine to do the VPU builds
on a PC running Linux. "make -f Makefile.vpu" should then generate
the binary, named "vpu_disPipe.bin".

To allocate GPU memory for the pipeline and start running the VPU
binary, the "vpu_disPipe-loader" program in the "loader" directory
is used. It will load the binary "../vpu_disPipe.bin" by default if
no path/file name is specified on the command-line
(eg. "sudo ./vpu_disPipe-loader").

BUT vc4-toolchain doesn't actually make binaries that run on the VPU
directly, for some reason they will only run via the limited
rpi-open-firmware open-source GPU firmware, which we don't want to
use. So for now this is useless. We might switch to another C
compiler toolchain if this can't be easily resolved.

To build for the CPU, just run "make -f Makefile.raspbian". This
produces a executable named "vpu_disPipe". No loader is required for
this, it allocates the GPU memory itself and creates the
"/tmp/pitrex_gpu_mem" file. It should all work fine. Launch it with
"sudo ./vpu_disPipe &", then launch Pitrex programs normally and
they should display via it.

Note that GPU memory allocation fails after the video output has
been turned off with "sudo tvservice -o", which is normally required
to prevent glitches (not sure yet whether it still is once this runs
on the VPU). So make sure to execute "sudo tvservice -o" after the
GPU memory has been allocated for the vector pipeline.

More details are on the Wiki here:
http://www.ombertech.com/cnk/pitrex/wiki/index.php?wiki=GPU
http://www.ombertech.com/cnk/pitrex/wiki/index.php?wiki=GPU_Display_
Processing
